DÚVIDAS:
-Verificar se a leitura da data de nascimento está correta
-Verificar se o método que estamos a usar para retornar a opcao dos menus é correta.
-Perguntar se a struct relacionada aos menus é correta
-Rever a lógica de limpeza dos buffers
-Devo definir macros para os limites das opcoes dos menus?
-Uso de uma variável "global" apenas para confirmar se os ficheiros estão a abrir corretamente ou se é melhor
usar uma struct com variáveis de erro.
-Manter o ficheiro aberto durante as operações em memória ou fecha-lo e reabri-lo mais tarde? Abrir. fechar. Abrir, fechar
-Devemos assumir que os dados que estão nos ficheiros estaraão corretos?
-Inicializar as structs é uma boa ideia??
-Verificar se o uso da função atoi é correto ou devo usar outra como sscanf ou strtol
-NACIONALIDADES!!!!


-><-
void remover_espacos(char * str) {
    char * inicio = str;
    char * fim = NULL;

    //Se o início conter um espaço, vai avançar o ponteiro uma casa, até essa casa deixar de ser um espaço.
    while (*inicio == ' ') inicio++;

    // Copiar a string sem espaços para o array inicial
    if (inicio != str) {
        memmove(str, inicio, strlen(inicio) + 1); //É uma versão melhorada do memcpy (evita a sobreposição)
    }

    //Ponteiro para o último caractere
    fim = str + strlen(str) - 1;
    while (fim > str && *fim == ' ') { //verifica se o fim tem um espaço em branco, se sim, anda com o ponteiro uma casa para trás e repete
        fim--;
    }

    //Colocamos o nul char no final, de modo a sinalizar o fim da string. 
    *(fim + 1) = '\0';
}


void separar_parametros(char * linha) {
    char * inicio = linha; //Ponteiro para o inicio da linha
    char * fim = NULL;

    int indice = 0; //Indice do array

    while(*inicio != '\0') { //Se não for o fim da linha entramos no loop
        fim = inicio; //

        //Vamos veriricar se o ponteiro atual de fim é um separador ou o fim da linha, caso não seja avançamos
        while(*fim != SEPARADOR && *fim != '\0') fim++;
        //Se estamos aqui, é porque ou estamos num parametro ou a linha acabou
        char temp = *fim; //Armazena o tab ou o nul char
        *fim = '\0'; //vai terminar a string de inicio (ou seja, um parametro)
        remover_espacos(inicio);

        if (*inicio != '\0') {
            linha[indice] = inicio; //Guarda o ponteiro de inicio na posição indice POSSÍVEL ERRO AQUI
            indice++;
        }
        *fim = temp; //Volta a colocar o tab ou '\0' onde estava 
        inicio = (*fim == '\0') ? fim : fim + 1; //Verifica se já estamos no fim da string, se sim, inicio = fim, se não inicio = fim +1 (avança uma casa)
    }
}

-><-


______________________________________________________________________________________________________________

NOTAS:
short - hd
unsigned short - hu

//Se der NULL em todos os modos de abertura, quer dizer que há um erro crítico. Dar manage
//Se não der nulo nos outros modos de abertura quer dizer que o ficheiro não existia e foi criado

______________________________________________________________________________________________________________

A IMPLEMENTAR:
-Pedir confirmação antes de sair do programa
-Para a ultima pergunta podemos usar um array dentro de um array, basicamente aquilo é uma matriz, ou entao fazer da forma "convencional"
-REVER METODO LER INPUTS!!
-Carregar os dados todos para a ram no inicio do programa
-Fazer a divisao de win e linux na questao do terminal
-LIMPAR O BUFFER APÓS CADA OPERAÇÃO BÁSICA
-Talvez seja melhor implementar as operações básicas na main. averiguar como poderia ser feito.
-Dar uma vista de olhos pelas mensagens de erro e talvez aprimorá-las
-mecanismo de avanço página a página: printar 20, pausa, enter, repeat
-DEVEMOS GUARDAR EM FICHEIROS TXT E BINÁRIO!! DEVE SER UMA OPÇÃO
-Talvez seja uma boa ideia voltar a criar uma struct para os dados escolares