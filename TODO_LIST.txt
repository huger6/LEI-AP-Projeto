DÚVIDAS:
-Verificar dúvida do bug da linha incompleta em erros.txt.
______________________________________________________________________________________________________________

NOTAS:
short - hd
unsigned short - hu
*(array)@num_elementos - Usar esta expressão na aba de watch ao dar debug para ver o conteúdo de cada elemento do array
scanf deixa o \n no buffer
ler_linha_txt le o \n do buffer

//Se der NULL em todos os modos de abertura, quer dizer que há um erro crítico. Dar manage
//Se não der nulo nos outros modos de abertura quer dizer que o ficheiro não existia e foi criado

______________________________________________________________________________________________________________

A IMPLEMENTAR:
-Pedir confirmação antes de sair do programa
-Para a ultima pergunta podemos usar um array dentro de um array, basicamente aquilo é uma matriz, ou entao fazer da forma "convencional"
-REVER METODO LER INPUTS!!
-LIMPAR O BUFFER APÓS CADA OPERAÇÃO BÁSICA
-Dar uma vista de olhos pelas mensagens de erro e talvez aprimorá-las
-mecanismo de avanço página a página: printar 20, pausa, enter, repeat (ver depois)
-DEVEMOS GUARDAR EM FICHEIROS TXT E BINÁRIO!! DEVE SER UMA OPÇÃO
-Talvez seja uma boa ideia voltar a criar uma struct para os dados escolares
-Nacionalidades devem ser variadas, e não devem ser verificadas
-Uso de atoi e strtol esta correto. Se falharem, devemos passar a linha
-Fazer a verificação na leitura se não tem nenhum tab, se tiver, classificar a entrada como inválida.
-Devemos assumir que os dados que estão nos ficheiros estaraão corretos? Alguns, como espaços e no caso do user inserir espaço entre os nomes
-Talvez seja benéfico adicionar mais caracteres na leitura da data de nascimento
-O que fazer no caso de um dado estar inválido? COPIAR PARA UM FICHEIRO DE ERROS
!!-Procurar código com procura binária e ordenar sempre o vetor após cada edição do estudante
-Na listagem com avanço página a página, podemos fazer com que cada 20 linhas sejam guardadas num array novo (em baixo)
ex: temos 201 linhas para listar, fazíamos 201 % 20 = 1, e depois fazíamos for (int i = 0; i < (201-1)/20;i++) e aí guardavamos um array com a info,
e depois obtemos o último array com 1 linha apenas, e com isso, através dos índices dos i's, podemos fazer com que o user avance ou ande para trás na pag
poderia ser criado uma espécie de legenda para o user saber os comandos (possível, mas para melhor eficiência não usar arrays)
-Vamos ASSUMIR que se o aluno não for eliminado, O CÓDIGO NÃO PODERÁ SER ALTERADO
-Carregar, ordenar e depois validar o codigo de escolares
-Usar o merge sort porque mantém a ordem inicial
-Mais eficiente e escolhemos esta porque por norma não haverá muitos duplicados
-Para o menu podemos usar a struct atual dentro de Uni e definir vários char, tipo p, g, e, x, ...
-Realçar o erro na linha em erros.txt
-verificar_codigoss_escolares_sem_aluno pode ser mais eficiente(ver comentário)
-

______________________________________________________________________________________________________________

BUGS:

O PRIMEIRO ELEMENTO DO ARRAY ESTÁ A FICAR EM BRANCO
LIMPAR_BUFFER NA INSERÇÃO DE ESTUDANTES (do nome)
faltam \n's antes das mensagens de erro nas validações.
quando um código é inválido temos de colocar o pressione enter
validar_nacionalidade está a dar uma mensagem seguida e temos de dar 2 espaços para avançar.
ao inserir estudantes e clicar em repetir, o programa sai??
-Nome: 1\n ; Nascimento: 2\n ; media_atual: 2\n
-No ficheiro de erros, a ultima linha fica sem o \n (acontece porque o \n é lido em ler_linha_txt (já nao))

#BUG DA LINHA CORTADA @RESOLVIDO
-a linha com gabriel carvalho está a ser cortada ao meio aparentemente sem razaão alguma, é a única
SE A LINHA TIVER A MESMA FORMATAÇÃO DE ESPAÇOS QUE A DO GABRIEL TAMBEM DA ERRO
Se não houver espaço antes de Gabriel a linha já aparece toda(remover espacos deve estar a funcionar mal)

Problema: A linha estava a ser alterada pelos outros ponteiros em separar_parametros.
Solução: Copiar a linha e trabalhar com uma cópia de modo a preservar os dados originais.

#BUG AO INSERIR_ESTUDANTE @RESOLVIDO TEMPORARIAMENTE
-Codigo entra bem 
-Nome, dou enter, enter, enter
-data, dou enter, enter - RESOLVIDO RETIRANDO limpar_buffer de detrás de ler_data.
-nacionalidade, dou enter, enter
-matriculas está bem
-ects também
-ano também
-media também

repetir com 's' fica o ecrã empty e nem com enter reinicia. Após escrever algo e dar enter aparece a mensagem de código inválido.

Solução: Não usar limpar_buffer exceto quando a entrada for CERTAMENTE inválida. Pode levar a strings erradas no entanto.

#BUG ARRAY + 1 @RESOLVIDO
//Foi assim que se deu debug
printf("%d\n", bd->aluno[0].codigo);
printf("%d\n", bd->aluno[bd->tamanho_aluno - 1].codigo);
merge_sort_aluno(bd, 0, bd->tamanho_aluno);
printf("%d\n", bd->aluno[0].codigo);
printf("%d\n", bd->aluno[bd->tamanho_aluno].codigo);

Problema: merge_sort_aluno(bd, 0, bd->tamanho_aluno); terceiro parametro tem que ser -1 caso contrário vamos incluir um -1 da inicializzção do array,
que vai vir para baixo no merge sort.

#BUG 0 NO ARRAY @RESOLVIDO
-Acontecia no indice 1000 e 2000 do array.
-O indice passava a 0 em vez de -1.

Solução: a realocação estava a verificar erradamente o tamanho do array em carregar_dados. Foi acrescentado o + 1 para resolver.


#BUG ELIMINAR ESTUDANTES
Como replicar:
-Inserir um estudante.
-Eliminar esse estudante.
-Repetir eliminação.
-Eliminar 1234.

O programa fecha abruptamente
______________________________________________________________________________________________________________

FUTURAMENTE:

-opcao linguagem
-ler ficheiro erros.txt e printar os erros.
-eliminação de códigos por intervalos


______________________________________________________________________________________________________________

A ANOTAR NO RELATÓRIO

-Tentámos usar o menor num de librarias extra possível.
-separar_parametros podia ter sido substituido por strtok mas nós já tinhamos feito a função antes de saber da existência dessa função no moodle, então acabamos por deixa la no código

-O error management na questão dos files podia ter sido melhor se usassemos a biblioteca errno.h
-O código está estruturado de modo a possibilitar a adição de novas features no futuro.
-Nacionalidade apesar do array estar limitado, está estruturado no código de modo a que seja fácil fazer a sua realocação, apenas seria necessário fazer uma função para o efeito.
-Em carregar_dados, foi utilizado a var primeiro_erro como alternativa a criar um array e guardar lá os erros(poupa memória)
-A escrita em erros.txt estava a sair desformatada com os \n's, então modificamos a função ler_linha_txt para eliminar o \n no final, apesar das outras funções já terem essa funcionalidade(validações, separar_parametros, etc)


IDEIA menu_estatisticas



-ter uma struct com várias variáveis dos menus 
seria apenas a 1 a que está com o menu ativo 
depois 